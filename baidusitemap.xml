<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">

    
  <url>
    <loc>http://ripeconan.com/2014/11/10/class_knn/</loc>
    <lastmod>2014-11-10T15:19:15.000Z</lastmod>
    <data>
        <display>
        <title>class 包中的 knn 系列函数</title>
        <pubTime>2014-11-09T16:00:00.000Z</pubTime>
        
        <tag>R package </tag>
         
        <tag>R函数 </tag>
         
         <content><![CDATA[<h2 id="函数功能">函数功能</h2>
<p>对测试集的每一行，去找训练集里欧式距离最近的 k 行，利用草根民主法，决定测试集该行的类别。</p>
<p><strong>class</strong> 包中还有两个和 <strong>knn</strong> 相关的函数：<strong>knn1</strong>, <strong>knn.cv</strong><br>这三个包处理的问题分别是：</p>
<ul>
<li>knn k-Nearest Neighbour Classification</li>
<li>knn1 1-nearest neighbour classification</li>
<li>knn.cv k-Nearest Neighbour Cross-Validatory Classification</li>
</ul>
<h2 id="函数参数说明">函数参数说明</h2>
<h3 id="knn_的函数说明"><strong>knn</strong> 的函数说明</h3>
<p><strong>knn</strong> 函数形式是  <code>knn(train, test, cl, k = 1, l = 0, prob = FALSE, use.all = TRUE)</code> , 重要的参数如下：</p>
<ul>
<li>train 训练集数据，可以是矩阵或者数据框类型</li>
<li>test 测试集数据，可以是矩阵或者数据框类型</li>
<li>cl 训练集对应的真实分类数据，应该是因子类型的向量</li>
<li>k 选择的近邻个数</li>
</ul>
<h3 id="knn1_的函数说明"><strong>knn1</strong> 的函数说明</h3>
<p><strong>knn1</strong> 函数形式是 <code>knn1(train, test, cl)</code>，即 <strong>knn</strong> 中选择 <code>k = 1</code> 的情况，因此 <strong>knn1</strong> 是 <strong>knn</strong> 的一个退化情况 </p>
<h3 id="knn-cv_的函数说明"><strong>knn.cv</strong> 的函数说明</h3>
<p><strong>knn.cv</strong> 函数形式是  <code>knn.cv(train, cl, k = 1, l = 0, prob = FALSE, use.all = TRUE)</code>，其使用的方法是 <strong>leave-one-out cross validation</strong>。即所有的样本点都算到训练集中去，不设置测试集。对每个训练集中的样本点，都使用剩余的样本点中的 k 个最近邻来进行投票，从而决定该样本点的分类。</p>
<h2 id="函数返回值说明">函数返回值说明</h2>
<p>该系列函数返回一个<strong>因子</strong>向量，是测试集对应的分类(在 <strong>knn.cv</strong> 中是训练集对应的分类)</p>
<h2 id="函数使用示例">函数使用示例</h2>
<h3 id="数据集情况">数据集情况</h3>
<p>我们使用 R 自带的 <code>iris3</code> 数据集，先看看数据大致情况</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class(iris3)</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#<span class="array"># </span>[<span class="number">1</span>] <span class="string">"array"</span></div></pre></td></tr></table></figure>



<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dim(iris3)</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">## [1] 50  4  3</span></div></pre></td></tr></table></figure>

<p>数据是以三维数组的形式存放，第三维度即3种鸢尾属植物，对于每一种植物，我们采集了4个特征，分别是</p>
<p>-Sepal.Length 花萼长度<br>-Sepal.Width 花萼宽度<br>-Petal.Length 花瓣长度<br>-Petal.Width 花瓣宽度</p>
<p>每种植物，我们采集了50个样本</p>
<h3 id="数据集处理">数据集处理</h3>
<p>我们对每种植物各选择25个样本，组成训练集，因此训练集的大小是75个样本</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">train &lt;- rbind(iris3[<span class="number">1</span>:<span class="number">25</span>,,<span class="number">1</span>], iris3[<span class="number">1</span>:<span class="number">25</span>,,<span class="number">2</span>], iris3[<span class="number">1</span>:<span class="number">25</span>,,<span class="number">3</span>])</div></pre></td></tr></table></figure>

<p>同样，每种植物剩下的25个样本，组合起来，作为测试集</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">test &lt;- rbind(iris3[<span class="number">26</span>:<span class="number">50</span>,,<span class="number">1</span>], iris3[<span class="number">26</span>:<span class="number">50</span>,,<span class="number">2</span>], iris3[<span class="number">26</span>:<span class="number">50</span>,,<span class="number">3</span>])</div></pre></td></tr></table></figure>

<p>再准备好训练集的分类数据向量，要求是因子类型，所以要转化一下</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cl &lt;- factor(c(rep(<span class="string">"s"</span>,<span class="number">25</span>), rep(<span class="string">"c"</span>,<span class="number">25</span>), rep(<span class="string">"v"</span>,<span class="number">25</span>)))</div></pre></td></tr></table></figure>

<h3 id="使用_knn_预测">使用 knn 预测</h3>
<p>最后，使用 <strong>knn</strong> 函数，选择最邻近的 3 个样本点来投票</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(class)</div><div class="line">final &lt;- knn(train, test, cl, k = <span class="number">3</span>)</div><div class="line">final</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">##  [<span class="number">1</span>] s s s s s s s s s s s s s s s s s s s s s s s s s <span class="built_in">c</span> <span class="built_in">c</span> v <span class="built_in">c</span> <span class="built_in">c</span> <span class="built_in">c</span> <span class="built_in">c</span> <span class="built_in">c</span> v <span class="built_in">c</span></div><div class="line">## [<span class="number">36</span>] <span class="built_in">c</span> <span class="built_in">c</span> <span class="built_in">c</span> <span class="built_in">c</span> <span class="built_in">c</span> <span class="built_in">c</span> <span class="built_in">c</span> <span class="built_in">c</span> <span class="built_in">c</span> <span class="built_in">c</span> <span class="built_in">c</span> <span class="built_in">c</span> <span class="built_in">c</span> <span class="built_in">c</span> <span class="built_in">c</span> v <span class="built_in">c</span> <span class="built_in">c</span> v v v v v v v v v v <span class="built_in">c</span> v v v v v v</div><div class="line">## [<span class="number">71</span>] v v v v v</div><div class="line">## <span class="type">Levels</span>: <span class="built_in">c</span> s v</div></pre></td></tr></table></figure>

<p>我们可以看一下正确率如何</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> - sum(cl != final)/length(cl)</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">## [1] 0.9333333</span></div></pre></td></tr></table></figure>

<h3 id="使用_knn1_预测">使用 knn1 预测</h3>
<p>如果使用 knn1 函数进行预测，则选择的就是最近的一个样本点来直接做决定</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">final1 &lt;- knn1(train, test, cl)</div><div class="line"><span class="number">1</span> - sum(cl != final1)/length(cl)</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">## [1] 0.9466667</span></div></pre></td></tr></table></figure>

<p>可以看到，<strong>knn1</strong> 在本例中的正确率要高于 k = 3 时的 <strong>knn</strong> </p>
<h3 id="使用_knn-cv_预测">使用 knn.cv 预测</h3>
<p>由于在 <strong>knn.cv</strong> 中不设置测试集，所以要把所有的样本点都放到训练集中去，因此训练集共 150 个样本点</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">train &lt;- rbind(iris3[,,<span class="number">1</span>], iris3[,,<span class="number">2</span>], iris3[,,<span class="number">3</span>])</div></pre></td></tr></table></figure>

<p>同样，训练集对应的真实分类数据也是长度为 150 的向量</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cl.cv &lt;- factor(c(rep(<span class="string">"s"</span>,<span class="number">50</span>), rep(<span class="string">"c"</span>,<span class="number">50</span>), rep(<span class="string">"v"</span>,<span class="number">50</span>)))</div></pre></td></tr></table></figure>

<p>最后，对训练集的每一行做预测，利用其余行的 3 个最近邻来投票</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">final.cv &lt;- knn.cv(train, cl.cv, k = <span class="number">3</span>)</div><div class="line"><span class="number">1</span> - sum(cl.cv != final.cv)/length(cl.cv)</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">## [1] 0.96</span></div></pre></td></tr></table></figure>

<p>可以看到，iris3 中对这三种方法的预测效果排序，<strong>knn.cv(k = 3)</strong> 优于 <strong>knn1</strong> 优于 <strong>knn(k = 3)</strong></p>
]]></content>
         
         
           
             
              <breadCrumb title="Machine Learning" url="http://ripeconan.com/categories/Machine-Learning/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://ripeconan.com/2014/10/23/recent%20to%20do/</loc>
    <lastmod>2014-10-23T01:29:39.000Z</lastmod>
    <data>
        <display>
        <title>近期学习内容安排:2014年第四季度</title>
        <pubTime>2014-10-23T01:19:55.000Z</pubTime>
        
        <tag>To Do </tag>
         
         <content><![CDATA[<h2 id="书目阅读">书目阅读</h2>
<ul>
<li><p>统计科普类</p>
<ol>
<li>无处不在的统计</li>
<li>漫画统计学入门</li>
<li>趣话概率——兼话《红楼梦》中的玄机</li>
<li>漫话信息时代的统计学</li>
<li>爱上统计学</li>
<li>统计数字会撒谎</li>
</ol>
</li>
<li><p>R语言编程类</p>
<ol>
<li>统计模拟及其R实现</li>
<li>ggplot2:数据分析与图形艺术</li>
<li>数据挖掘与R语言</li>
<li>R语言实战</li>
<li>R语言经典实例</li>
<li>R数据可视化手册</li>
<li>统计建模与R软件</li>
<li>R语言与统计分析</li>
<li>复杂数据统计方法——基于R的应用</li>
</ol>
</li>
<li><p>Python编程类</p>
<ol>
<li>Python语言程序设计:英文版.影印版</li>
<li>Natural language processing with python.英文影印版</li>
<li>NumPy攻略:Python科学计算与数据分析</li>
<li>统计思维:程序员数学之概率统计</li>
</ol>
</li>
<li><p>其他数据分析类</p>
<ol>
<li>数据之魅:基于开源工具的数据分析</li>
<li>驾驭大数据</li>
<li>大数据:互联网大规模数据挖掘与分布式处理</li>
</ol>
</li>
<li><p>概率统计理论类</p>
<ol>
<li>概率论基础教程</li>
<li>概率论及其应用</li>
<li>深入浅出数据分析</li>
<li>Survival Analysis</li>
<li>Logistic Regression</li>
</ol>
</li>
</ul>
<hr>
<h2 id="MOOC学习">MOOC学习</h2>
<ol>
<li>数据分析与统计推断(Duke)</li>
<li>Python交互编程入门(Rice)</li>
<li>机器学习基石(NTU)</li>
<li>海量数据挖掘(Stanford)</li>
</ol>
<hr>
<h2 id="研究方向">研究方向</h2>
<ol>
<li>半参数模型的统计模拟</li>
<li>非独立随机变量的统计模拟</li>
<li>机器学习在实时交通预测上的应用</li>
<li>通过API来获取实时数据并加工整理</li>
</ol>
]]></content>
         
         
           
             
              <breadCrumb title="Learning" url="http://ripeconan.com/categories/Learning/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://ripeconan.com/2014/10/22/Power%20Map/</loc>
    <lastmod>2014-10-22T14:19:15.000Z</lastmod>
    <data>
        <display>
        <title>Power Map 学习笔记</title>
        <pubTime>2014-10-21T16:00:00.000Z</pubTime>
        
        <tag>Excel </tag>
         
        <tag>可视化 </tag>
         
         <content><![CDATA[<h2 id="Power_Map_介绍">Power Map 介绍</h2>
<p><strong>Power Map</strong> 是微软2013年推出的 Excel2013 的插件， <strong>Power BI</strong> 的组件之一，其前身是 <strong>Geoflow</strong>。以下是 <strong>Power Map</strong> 的官方简介：</p>
<blockquote>
<p>Power Map is a new 3D visualization add-in for Excel for mapping, exploring,<br>and interacting with geographical and temporal data, enabling people to<br>discover and share new insights.</p>
</blockquote>
<p>点击<a href="http://www.microsoft.com/en-us/download/details.aspx?id=38395" target="_blank" rel="external">下载链接</a>进入下载页面，安装较为容易，也可以参考<a href="http://jingyan.baidu.com/album/03b2f78c4f3fac5ea237ae06.html" target="_blank" rel="external">安装教程</a></p>
<hr>
<h2 id="横向数据的展示（与时间无关）">横向数据的展示（与时间无关）</h2>
<p><strong>Power Map</strong> 主要应用于具有地理位置信息的数据，其可以接受的地理位置有：  </p>
<ul>
<li>国家/地区</li>
<li>省/市/自治区</li>
<li>城市</li>
<li>经纬度</li>
<li>邮政编码 </li>
<li>…… </li>
</ul>
<p>为了方便起见，我们选用以下形式的 <em>Excel</em> 数据集来进行测试：<br><img src="/img/powermap/1.png" alt="横向数据"></p>
<p>选中数据所在单元格之后，点击 <code>插入——启动 Power Map</code>，进入地图界面：<br><img src="/img/powermap/2.png" alt="地图界面"></p>
<p>按照右下方提示，将<strong>地区</strong>变量选择为<strong>省/市/自治区</strong>，进入下一步，<br>则地图会旋转到地区变量匹配的区域：<br><img src="/img/powermap/3.png" alt="地区匹配"></p>
<p>此时进入到选择<strong>绘制变量</strong>的阶段，我们需要从已有变量中勾选出我们想要展示的变量（右上角）。对于右下角的界面，也有变化：<br><img src="/img/powermap/4.png" alt="可视化选项"></p>
<p>上面五个图形分别是： </p>
<ul>
<li>堆积柱形图(Stacked)</li>
<li>簇状柱形图(Clustered)</li>
<li>气泡图(Bubble)</li>
<li>热度地图(Heat)</li>
<li>将可视化转为区域</li>
</ul>
<p>前四个图形对应的是不同的数据展现形式，而展现的位置，是地区变量对应的一个点(例如，地区变量是省的名称，则数据就会到该省的省会城市所在地的点进行绘制)；而最后一种<strong>将可视化转为区域</strong>，则是将绘制范围从点转为面(即在该省所在面积上进行绘制)。下面将举例说明。</p>
<hr>
<h3 id="柱形图">柱形图</h3>
<p>对于柱形图的 <strong>高度、类别、时间</strong> 这三个需要填补的字段(或者称为变量)，我们应该分别填入<strong>数值型变量、分类变量、日期时间变量</strong>。在本例中，<em>变量1</em>和<em>变量2</em>是数值型变量，所以我们可以将其添加到高度中，以下是<strong>堆积柱形图</strong>和<strong>簇状柱形图</strong>的效果：<br><img src="/img/powermap/stack.png" alt="堆积柱形图"><br><img src="/img/powermap/cluster.png" alt="簇状柱形图"></p>
<p>这里面有三点值得注意：  </p>
<ol>
<li>两张地图的视角不一，这是因为我们可以使用地图的旋转和拉伸等方式来操作 <img src="/img/powermap/rotate.png" alt="旋转按钮"></li>
<li>右上角默认显示了图例，我们可以对其进行编辑，如图层名称，柱形颜色</li>
<li>我们将变量的数值展示方式由默认的<strong>求和</strong>改为了<strong>无聚合</strong>，其他还有几种，如：<ul>
<li>平均</li>
<li>计数</li>
<li>最大值</li>
<li>最小值</li>
</ul>
</li>
</ol>
<hr>
<h3 id="气泡图">气泡图</h3>
<p>对于气泡图，我们可以让气泡的大小表示单个变量的值的大小，比如：</p>
<p><img src="/img/powermap/bubble1.png" alt="单变量气泡图"></p>
<p>也可以使用气泡图展示多个变量值。此时，让不同地区的气泡维持同样大小，但气泡中不同颜色比例代表了该地区不同的值的大小关系，具体大家可以尝试一下。我们还可以在右边的设置窗口中，调节气泡的<strong>不透明度、大小、厚度</strong></p>
<p><img src="/img/powermap/bubble2.png" alt="多变量气泡图"></p>
<hr>
<h3 id="热度图">热度图</h3>
<p>热度图只能展示不同地区单变量的值，根据图例我们可以看到颜色和值的关联性，进而通过颜色的变化来了解地图上不同地区的变量值的大小。同样，使用设置窗口，我们可以更改热度图的<strong>不透明度、色阶、影响半径</strong></p>
<p><img src="/img/powermap/heat.png" alt="热度图"></p>
<hr>
<h3 id="将可视化更改为区域">将可视化更改为区域</h3>
<p>前面提到过，这个选项是将绘制范围从点转为面，按照各个地区的轮廓，在其内进行数值展示。如果对单变量的值进行绘制的话，则颜色和值的大小相关。关于此选项还有一些可以深入调试的地方，有兴趣的可以自行尝试。</p>
<p><img src="/img/powermap/region.png" alt="区域图"></p>
<hr>
<h2 id="纵向数据的展示（按时间变化）">纵向数据的展示（按时间变化）</h2>
<h3 id="数据集选取">数据集选取</h3>
<p><strong>Power Map</strong> 在横截面时间上的数据展示只是静态的，其更强大的功能在于<strong>动态可视化</strong>，即引入日期时间变量，让数据动起来。我们使用如下的数据集来说明 <strong>Power Map</strong> 对纵向数据的展示：</p>
<p><img src="/img/powermap/longitudinal.png" alt="纵向数据"></p>
<p>对该数据的说明：</p>
<ol>
<li>地区共有六个：河北、山东、山西、内蒙古、贵州、云南，后面四个地区的变量数据与前面两个相同</li>
<li>日期变量的数据格式为 <strong>日期</strong>，可以点击 <strong>右键——设置单元格格式</strong> 来修改</li>
</ol>
<hr>
<h3 id="引入时间变量来生成动画">引入时间变量来生成动画</h3>
<p>仍然将<strong>地区</strong>变量选择为<strong>省/市/自治区</strong>，进入下一步。勾选 <strong>日期</strong> 变量，由于其格式为 Excel 可识别的日期格式，所以会自动进入到右下方的 <strong>时间</strong> 选项中，注意到此时地图左上角有了时间戳：</p>
<p><img src="/img/powermap/time1.png" alt="时间设置"></p>
<p>然后勾选想要展示的变量，对于数值型变量，会直接进入到 <strong>高度</strong> 选项中。在本例中，我们勾选 <strong>变量1</strong> 和 <strong>变量2</strong>，并将展示方式设置为 <strong>簇状柱形图</strong>，对变量的操作选择 <strong>无聚合</strong></p>
<p><img src="/img/powermap/timeplay.png" alt="时间播放"></p>
<p>注意到地图下方有一个类似于播放器的播放按钮，点击即可进入播放</p>
<iframe height="498" width="510" src="http://player.youku.com/embed/XODA5MTY2MTcy" frameborder="0" allowfullscreen></iframe>

<p>可以看到，随着左上角时间的推移，我们的柱形图也在变化，这就实现了动态的数据可视化。<br>如果对播放速度不满意，我们还可以通过右上方的设置按钮进行多种播放条件进行调整：</p>
<p><img src="/img/powermap/timeconfig.png" alt="播放设置"></p>
<p>值得一提的是，<strong>效果</strong> 选项的调整，只有在点击 Excel 左上角的 <strong>播放演示</strong> 按钮后才能看到最终的效果。</p>
<hr>
<h3 id="时间变量调整">时间变量调整</h3>
<p>如果我们的数据并非以日为单位来采集的话， <strong>Power Map</strong> 该如何对其进行展示？假设我们将刚才的数据集的日期变量进行一下修改：</p>
<p><img src="/img/powermap/timechange.png" alt="时间调整"></p>
<p>此数据集仍然具有六个地区，与刚才数据集的唯一区别，就是日期变量变为<strong>以月为单位</strong>了，但日期变量的格式还是 Excel 可识别的日期格式。  </p>
<p>对此数据集进行<strong>地区选择——时间选择——高度选择</strong>这一系列流程后，我们可以对其进行播放。可以看到，时间的流逝速度加快，我们仍然在默认设置的时间内(我的默认设置是播放6秒)，观看完从2014-1-1至2014-10-1的整个动画。可以预想到，随着我们数据量的增大，当日期变量取值更加紧密的时候(比如每天都有数据点，整个数据的日期跨度为1年)，我们可能需要延长动画播放时间，才能较好的理解数据变化的模式。</p>
<hr>
<h3 id="其他的时间格式">其他的时间格式</h3>
<p>如果我们的数据是类似于传感器采集的更高频率的数据，该怎么操作？对于精确到秒的时间变量，我们只需要注意将时间变量数据格式转为 Excel 可识别的即可，如下图：</p>
<p><img src="/img/powermap/hour.png" alt="小时"></p>
<p>注意到，虽然日期变量的显示格式只是<strong>5:00:00</strong>，但是 Excel 中实际存储的是<strong>2014/1/1  5:00:00</strong>。对此数据进行动态可视化操作也是可行的，流程如上。</p>
<hr>
<h2 id="其他功能">其他功能</h2>
<p>事实上， <strong>Power Map</strong> 还有一些其他功能值得说一下：</p>
<ol>
<li><p>主题的选取。 <strong>Power Map</strong> 提供了多种地图背景供选择，如：<img src="/img/powermap/theme.png" alt="主题"></p>
</li>
<li><p>平面地图。通过点击菜单栏上的<strong>平面地图</strong>，我们可以讲地图设置为平面的。不过旋转和拉伸动作仍然可以操作，并且各种图形的绘制均无影响。<img src="/img/powermap/2d.png" alt="平面地图"></p>
</li>
<li><p>添加图层。类似于 <strong>Photoshop</strong> 的原理，我们可以在同一张背景地图上，进行不同图层的绘制，最后会将所有图层效果叠加。这使得我们可以将不同效果的图形结合起来，仅举一例：<img src="/img/powermap/layer.png" alt="图层"></p>
</li>
<li><p>形状。如果画柱形图，可以选择不同的形状，如：<img src="/img/powermap/shape.png" alt="不同形状"></p>
</li>
<li><p>还有很多功能，如二维图表、文本框等等，在此不一一赘述。</p>
</li>
</ol>
]]></content>
         
         
           
             
              <breadCrumb title="Visualization" url="http://ripeconan.com/categories/Visualization/"/>
          
        </display>
    </data>
    </url>

    
    
    
  <url>
    <loc>http://ripeconan.com/2014/10/18/cumsum/</loc>
    <lastmod>2014-10-18T11:16:13.000Z</lastmod>
    <data>
        <display>
        <title>cumsum</title>
        <pubTime>2014-10-18T10:46:40.000Z</pubTime>
        
        <tag>R函数 </tag>
         
         <content><![CDATA[<h2 id="函数功能">函数功能</h2>
<p>计算向量的累积和并返回  </p>
<p>cum 系列还有另外三个函数：cumprod, cummin, cummax<br>它们的作用分别是计算向量的累积的乘积、极小值、极大值，并返回</p>
<h2 id="函数参数说明">函数参数说明</h2>
<p>cum 系列函数只有一个参数：cumsum(x), cumprod(x), cummin(x), cummax(x)  </p>
<ol>
<li>当使用 cumsum 或 cumprod 时，x 可以是数值型(numeric)或复数型(complex)的向量、矩阵、数据框，因为数值型和复数型可做求和、求积。</li>
<li>当使用 cummin 或 cummax 时，x 只能是数值型的向量、矩阵、数据框。</li>
</ol>
<h2 id="函数返回值说明">函数返回值说明</h2>
<p>当 x 是向量、矩阵时，cum 系列函数返回的是向量，因为矩阵的本质也是向量；当 x 是数据框时，返回值则仍为数据框。</p>
<h2 id="函数使用示例">函数使用示例</h2>
<p>对数值型向量求和：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cumsum(<span class="number">1</span>:<span class="number">10</span>)</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">##  [1]  1  3  6 10 15 21 28 36 45 55</span></div></pre></td></tr></table></figure>

<p>对数值型矩阵求和，结果返回仍是向量：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cumsum(matrix(<span class="number">1</span>:<span class="number">12</span>, nrow = <span class="number">3</span>))</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">##  [1]  1  3  6 10 15 21 28 36 45 55 66 78</span></div></pre></td></tr></table></figure>

<p>对数据框求和，返回结果仍然是数据框，对每个变量做操作：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cumsum(data.frame(a = <span class="number">1</span>:<span class="number">10</span>, b = <span class="number">21</span>:<span class="number">30</span>))</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">##     a   b</span></div><div class="line"><span class="preprocessor">## 1   1  21</span></div><div class="line"><span class="preprocessor">## 2   3  43</span></div><div class="line"><span class="preprocessor">## 3   6  66</span></div><div class="line"><span class="preprocessor">## 4  10  90</span></div><div class="line"><span class="preprocessor">## 5  15 115</span></div><div class="line"><span class="preprocessor">## 6  21 141</span></div><div class="line"><span class="preprocessor">## 7  28 168</span></div><div class="line"><span class="preprocessor">## 8  36 196</span></div><div class="line"><span class="preprocessor">## 9  45 225</span></div><div class="line"><span class="preprocessor">## 10 55 255</span></div></pre></td></tr></table></figure>

<p>对复数型向量，可以求积：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x &lt;- c(<span class="number">1</span> + <span class="number">2i</span>, <span class="number">2</span> - <span class="number">3i</span>, <span class="number">5</span> + <span class="number">10i</span>); </div><div class="line">cumprod(x)</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">## [1]  1+ 2i  8+ 1i 30+85i</span></div></pre></td></tr></table></figure>

<p>对数值型向量求min：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cummin(c(<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>))</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">## [1] 3 2 2 1 1</span></div></pre></td></tr></table></figure>

<p>对数据框，每个变量分别求max：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cummax(data.frame(a = c(<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>), b = c(<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>)))</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">##   a b</span></div><div class="line"><span class="preprocessor">## 1 3 1</span></div><div class="line"><span class="preprocessor">## 2 3 8</span></div><div class="line"><span class="preprocessor">## 3 5 8</span></div><div class="line"><span class="preprocessor">## 4 5 8</span></div><div class="line"><span class="preprocessor">## 5 5 8</span></div></pre></td></tr></table></figure>

]]></content>
         
         
           
             
              <breadCrumb title="R" url="http://ripeconan.com/categories/R/"/>
          
        </display>
    </data>
    </url>

</urlset>
